
1. How does findViewById work internally ?
Ans : 
 In the XML file when we add an element and set the properties to it we only set the values for these properties,
 now for each element, there is a class that draws it at the screen, this class has attributes with the 
 same names of the properties in the XML file now using algorithms of read-write from files these values 
 from the XML file are transmitted to the java file (class) of the element, and then the class draws that element on the screen.
 Before the class of the element draws it, there is a superclass of all elements,
 the parent for all of them it is called View (every element in the activity is called view) this class has the basic
 properties of all elements and this class is the one which the properties from the XML file will be transmitted to it.
 Method findViewById() returns an object of View type, this object holds the properties values then we need to cast it to the specific element, for example, TextView which is a class to draw the text view this class and all elements' classes are 
 subclasses of View class so what we do is downcasting, that when this method returns the object of View type we downcast it to the element class
 How it finds the properties? it finds the properties of the element using the id if the tag in the XML file first it searches in t
 he XML file for the tag that holds the element's name and then it looks at the id if it is the id which it wants then it takes it 
 otherwise it searches for another tag (with the same element name).
 We give it the id by this approach. there is a class is called R (resources),
 this class has nested classes (id, string, colors) these classes have attributes from the same type and hold specific values,
 for instance, the id class it has attributes that stores each id of each element in the XML file,
 so when we want to give the method findViewById() the id we go to this class and tell it to enter id class and choose the id of the element we want.
 And the process goes that it enters to the XML file and look for the element that has this id and it takes the properties and passes them to the 
 class view object and when it returns the object we downcast it to the element's class that we want to draw it and deal with it.
 Thread : https://stackoverflow.com/questions/35357734/how-does-findviewbyid-work
 Very good explanation : https://medium.com/@sm3.saurabhmishra/android-deep-dive-findviewbyid-547177fbe880


2. What is AIDL in android ? 

And : https://developer.android.com/develop/background-work/services/aidl

✅ What is AIDL (Android Interface Definition Language)?

AIDL is Android’s way to define interfaces for Inter-Process Communication (IPC) between components running in different processes.
✨ Think of it like:

    AIDL is a contract between two Android components — usually from different apps — that want to talk to each other securely and efficiently.

For example:

    App A wants to get data from a service running in App B (e.g., getting the location, playing music, managing files).

    Android doesn't allow direct memory access across processes.

    So objects must be marshalled (serialized) and unmarshalled safely across process boundaries. AIDL handles this behind the scenes.

📌 When Should You Use AIDL?

Use AIDL if:

    You’re exposing a bound service to clients from different apps (processes).

    You want to handle multithreading in the service.

    You need high-performance, bidirectional communication (like callbacks, or data streams).

Don’t use AIDL if:

    You only need IPC within the same app → just use Binder directly.

    You don’t need multithreading → use Messenger.

🧠 Key Concepts & Things to Remember
Concept	Description
.aidl File	Defines the interface. Like IRemoteService.aidl.
Stub Class	Generated automatically; you extend this to implement the interface.
Binder	Android's base class for inter-process communication.
onBind()	Returns the implementation of the Stub to clients.
asInterface()	Used on the client side to get the usable object from the IBinder.
in, out, inout	Directional tags for complex types (not needed for primitives).
oneway	Marks methods as asynchronous/non-blocking.
Threading	IPC methods run on a Binder thread pool, not UI thread — always ensure thread safety!
📦 Real-world Example Use Cases

Here are some real Android system-level examples where AIDL is used — talk about these in your interview for a strong impression.
1. Android System Services

Many system services are defined via AIDL. For example:
🧭 LocationManagerService

    You call LocationManager to get GPS coordinates.

    Under the hood, it uses ILocationManager.aidl to communicate with the system service running in another process.

    This allows apps to request location updates from the centralized system process securely.

🎧 Media playback

    IMediaPlayerService.aidl & IMediaSession.aidl

    Used when apps communicate with the system's audio playback pipeline — like in Spotify, YouTube, or Google Play Music.

2. Play Store

    Google Play Services uses AIDL to expose APIs (e.g., license verification, in-app billing).

    Apps like your game can use IInAppBillingService.aidl to talk with the Play Store securely and perform in-app purchases.


Two apps:

    App A (Client) – Wants to get data

    App B (Service) – Offers the data via an AIDL interface

📊 Diagram – AIDL IPC Flow

[App A: Client]                                 [App B: Service]
----------------                                 ----------------
1. IRemoteService.aidl       --->               1. IRemoteService.aidl
2. bindService()             --->               2. onBind() returns Stub
3. onServiceConnected()      <---               3. Stub is sent as IBinder
4. call remote method        --->               4. Method runs in App B's thread pool
5. result returned           <---               5. Service processes and sends response

Both apps must include the same .aidl file in src/main/aidl.    


- What is a Bound Service, and how does AIDL use it?
📌 Bound Service:

A bound service is a service that allows components (clients) to bind to it and interact via a persistent connection — like calling methods, receiving callbacks, etc.
🤝 Relationship with AIDL:

AIDL is one way to define the interface that clients can use when they bind to the service. It’s especially used when:

    The client is from a different app/process

    You need complex or high-performance IPC

Service Lifecycle in Bound Service:

    onBind() is triggered when a client binds.

    It returns an IBinder object (Stub generated from AIDL).

    The client uses this to call remote methods.



3. What is Binder Class ?
Answer : 
In Android, the Binder class is a crucial part of the framework that enables Inter-Process Communication (IPC).
Think of it as the secure and efficient messaging system for Android processes.

In simple terms:

    Android applications and system components generally run in their own isolated memory spaces,
    in separate processes, for security and stability.

    When one of these processes needs to interact with another – whether it's an app talking to a system service,
    or even two parts of the same 
    app running in different processes – they cannot directly share memory or call functions on each other.
    The Binder mechanism provides the low-level foundation for these separate processes to communicate.
    It allows an object in one process to call methods on an object in another process, making it feel almost 
    like a local method call, despite the process boundary.

It's important to note that as Android developers, we rarely interact with the Binder class directly.
Instead, we leverage higher-level Android APIs that utilize Binder under the hood.
The most common ways we indirectly use Binder are through:

    Android's Core System Services: Almost every interaction with the Android OS relies on Binder.

    Bound Services: When you create your own Service that other components (potentially in different processes) can bind to and interact with.

    AIDL (Android Interface Definition Language): This is a tool that generates the necessary Binder boilerplate code for you, allowing you to define an interface for cross-process communication.

Here are a few realistic examples of where Binder is fundamental:

    Launching an Activity: When your app calls startActivity() to launch another activity (even one within your own app, if it's in a different process, or an activity from another app), your app's process uses Binder to communicate with the ActivityManagerService (which lives in the Android system server process). 
    It's the Binder that transmits the intent and other launch parameters, and facilitates the response back to your app.

    Displaying a Notification: When your app creates and publishes a notification using NotificationManager.notify(), 
    your app's process isn't directly drawing the notification on the screen. 
    Instead, it uses Binder to send the notification data (icon, text, pending intent, etc.) to the NotificationManagerService in the system process. 
    This system service then handles the actual display of the notification in the status bar and notification shade.

    Accessing System Services (like Location): When your app requests your current location using LocationManager.requestLocationUpdates(), 
    your app (Process A) doesn't directly access the GPS hardware. 
    It's the Binder that transmits your request to the Location Manager Service (running in the system server, Process B). 
    The service then gets the location and uses Binder again to send that data back to your application.

In essence, while we interact with high-level APIs like startActivity() or NotificationManager, 
it's the robust and efficient Binder framework that's always working behind the scenes, 
enabling all this crucial cross-process communication in Android."

4. Bound Service ?
Video : https://www.youtube.com/watch?v=_xNkVNaC9AI

A Bound Service in Android is a type of service that provides a client-server interface that 
allows components (like activities or other services), whether they are in the same process or a different process,
to bind to the service, send requests, receive results, and even perform IPC (Inter-Process Communication) if the client
and service are in separate processes.

Key Characteristics:

    Client-Server Interaction: It allows clients to directly interact with the service, calling methods on the service instance.

    Lifecycle Tied to Clients: The service is created when the first client binds to it and is destroyed when the last client 
    unbinds (unless it's also a started service).

    IPC Mechanism: It's the primary way to enable IPC between your own app's components, especially when using AIDL, 
    which relies heavily on Binder for the underlying communication.

    Returns an IBinder: When a client binds, the service's onBind() method returns an IBinder object. 
    This IBinder is the communication channel that the client uses to interact with the service. 
    This is where Binder (specifically, an object implementing IBinder) comes into play.

A Simple, Realistic Example: A Music Player App

Imagine you're building a music player. You want music to keep playing even if the user navigates away from the main UI (your Activity).

    The Service: You'd create a MusicPlaybackService that runs in the background. 
    This service contains all the logic for playing, pausing, skipping songs, etc.

    The Activity (Client): Your main MainActivity (the UI) needs to tell the MusicPlaybackService to play a song or pause it.

How a Bound Service solves this:

    Your MainActivity calls bindService() to connect to the MusicPlaybackService.

    The MusicPlaybackService implements an onBind() method which returns a custom IBinder object (often a Binder subclass you define, 
    or one generated by AIDL). This IBinder contains methods like play(), pause(), getNowPlayingSong().

    Once the MainActivity receives this IBinder object (in its onServiceConnected() callback), 
    it can then directly call methods like serviceBinder.play() or serviceBinder.getNowPlayingSong() as if it were calling a local object.

    The MusicPlaybackService will continue playing music in the background. If the user closes the MainActivity, it can unbind from the service,
    but the service might continue running if it was also started (e.g., to keep playing music in the notification). If it's only bound and 
    the last client unbinds, the service shuts down.

In essence, a Bound Service provides a direct, programmatic interface for other components to connect to and control a background
operation, making it ideal for features like media playback, network downloads that need status updates, or any scenario requiring
ongoing interaction with a background process."

5. What Happens When You Click on an App in Android ? 
Answer : 
=> https://dev.to/nikhildupally/what-happens-when-you-click-on-an-app-in-android-a-deep-dive-4dk4
    1. The Launcher Gets to Work

    When you tap an app icon, the Launcher (your home screen app) picks up the touch event. Here’s what happens next:

        Touch Processing: The system detects your touch through Android’s input framework and determines which icon was pressed.

        Intent Creation: The launcher creates an Intent that tells the system which app you want to open.

        Communicating with the System: It sends a request to the Activity Manager Service (AMS) via Binder IPC to start the app.

    2. Checking If the App is Already Running

    The Activity Manager Service (AMS), which is part of the Android system, now takes over and decides what to do next:

        Is the app already open? If the app is already running, AMS just brings it to the foreground.

        If not, find the process: AMS checks if the app’s process is active.

        Starting fresh: If the process isn’t running, AMS requests Zygote to start a new instance of the app.

    3. Zygote: The Process Factory

    Zygote is a special system process responsible for launching apps efficiently. Here’s what it does:

        Receiving the request: Zygote gets a command from AMS via a socket message.

        Forking a new process: Instead of creating a whole new process from scratch, Zygote forks itself to make a lightweight copy. This saves time and resources.

        Starting the Android Runtime (ART): The new process is now ready to load the app.

    4. Initializing the App

    Now that the app’s process is up and running, the Android Runtime (ART) takes over:

        Loading classes and resources: The app’s code and assets are loaded into memory.

        Calling main() method: The entry point of the app (ActivityThread.main()) is executed, setting up the main thread and event loop.

        Creating the Application object: The app’s Application class (defined in AndroidManifest.xml) is instantiated, and onCreate() is called.

    5. Creating and Rendering the First Screen

    After the app is initialized, the first activity is launched:

        AMS tells the app process to start an activity.

        ActivityThread handles the launch: The activity is created, and lifecycle methods (onCreate(), onStart(), onResume()) are executed.

        Rendering the UI: The app’s interface is drawn using ViewRootImpl and SurfaceFlinger, which handle OpenGL rendering and sending the image to your screen.

    6. Your App Appears!

The final step is making sure you see the app on your display:

    The UI updates sync with the screen’s refresh rate using Choreographer.

    SurfaceFlinger combines all the visual elements and sends the final frame to your phone’s display.

    Your app is now ready to use! 🎉


8. How to create LRU cache ? 

    What is LRU Cache?

    An LRU (Least Recently Used) Cache is a fixed-size cache that stores data, prioritizing the
    removal of the least recently accessed items when the cache reaches its capacity. It ensures
    that frequently used data remains quickly accessible.

    Where are LRU Caches Used in Android Apps?

    LRU Caches are predominantly used in Android apps for efficient memory management and performance optimization,
    particularly for resources that are frequently accessed but also consume significant memory.

    Most Common Use Cases of LRU Cache in Android Apps:

        Image Caching: This is the most common use case. Images loaded from the network or disk are stored in an LRU cache (e.g., in RAM) to prevent re-downloading or re-decoding them when they are viewed again (e.g., in a RecyclerView during fast scrolling).

        Bitmap Caching: Specifically for Bitmap objects, which are memory-intensive. An LruCache<String, Bitmap> is fundamental for smooth UI experience when displaying many images.

        Data Caching (API Responses): Caching frequently accessed data from network API calls (e.g., user profiles, product lists, configuration data) to reduce network requests and load times.

        RecyclerView Data Pre-fetching/Caching: Caching data for items in a RecyclerView that are just off-screen to improve the perceived loading speed during scrolling.

    How to Implement Your Own LRU Cache?

    In Android, the most straightforward way to implement your own LRU Cache is by using the android.util.LruCache class.

    Key Implementation Steps:

        Instantiate LruCache: Create an instance of LruCache, specifying the maximum size (e.g., in kilobytes for images, or number of items for data).
        Java

    // Example for caching Bitmaps, with a max size of 1/8th of app's max memory
    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
    final int cacheSize = maxMemory / 8; // Use 1/8th of the available memory for cache

    LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            // Return the size of the bitmap in kilobytes
            return bitmap.getByteCount() / 1024;
        }
    };

    Add to Cache (put): When data is loaded or generated, add it to the cache.
    Java

    // bitmap to be cached
    String key = "image_url_or_id";
    Bitmap loadedBitmap = ...;
    if (loadedBitmap != null) {
        bitmapCache.put(key, loadedBitmap);
    }

    Retrieve from Cache (get): Before loading data, check if it's already in the cache.
    Java

        Bitmap cachedBitmap = bitmapCache.get(key);
        if (cachedBitmap != null) {
            // Use cachedBitmap
        } else {
            // Load the bitmap (e.g., from disk or network)
            // ... then put it into the cache
        }

    Override sizeOf (Crucial for custom objects): For objects like Bitmaps, you must override sizeOf() to tell the cache how to calculate the size of each item (e.g., in bytes or kilobytes), so it can correctly manage its capacity. For simple objects like Strings, sizeOf might just return 1 to count items.
    This LruCache class handles the LRU eviction policy (removing the least recently used item when full) automatically, making implementation straightforward.

9. How view models work internally to preserve data accorss configuration changes ? 

    Easy to understnad explaintaion : https://www.droidcon.com/2025/01/13/understanding-viewmodel-persistence-across-configuration-changes-in-android/
    VeryDeep explaintaion : https://proandroiddev.com/how-viewmodel-works-under-the-hood-52a4f1ff64cf

    ViewModelStore: Every Activity or Fragment that uses a ViewModel has a ViewModelStore associated with it.
    This ViewModelStore is where the ViewModel objects are actually held.

    ViewModelProvider: When you request a ViewModel (e.g., ViewModelProvider(this).get(MyViewModel::class.java)),
    the ViewModelProvider does the following:

        It checks the ViewModelStore associated with the current scope (Activity or Fragment) to see if a
        MyViewModel instance already exists.

        If an instance exists, it returns the existing instance.

        If no instance exists, it creates a new MyViewModel instance and puts it in the ViewModelStore.

    Surviving Configuration Changes:

        When a configuration change occurs (like a screen rotation), the Activity or Fragment is destroyed and recreated.

        However, the ViewModelStore is not destroyed. It is managed by the Android framework and is tied to the scope's lifecycle in a special way.

        When the new Activity or Fragment is created, it gets the same ViewModelStore instance that was used before the configuration change.

        The ViewModelProvider is then called again. It checks the ViewModelStore, finds the existing MyViewModel instance, and returns it.

        This means the ViewModel object and all the data it holds (e.g., a list of users, a network request result) remain in memory and are not lost.

    The Role of onCleared(): The onCleared() method is called when the ViewModelStoreOwner (the Activity or Fragment) is finally finished. 
    This happens when the Activity is permanently destroyed (e.g., the user presses the back button and exits the app) or the Fragment is 
    detached and removed. This is the signal for the ViewModelStore to clear out the ViewModel objects.
    You can use this method to release resources (e.g., cancel a long-running network request).

In essence, the ViewModel is not a magic black box. It's an object stored in a special container (ViewModelStore) that is
designed to outlive the lifecycle of its associated Activity or Fragment during configuration changes. The ViewModelProvider acts as the gatekeeper, 
ensuring that the same instance is returned to the new Activity or Fragment after a configuration change. 
This simple but powerful pattern prevents data loss and simplifies the development of robust and responsive Android applications.


10. How FCM Push notificatinos system work internally ? 

    Amazing Explanation : https://blog.clix.so/how-push-notification-delivery-works-internally/


11. What are memory leaks ? How to detect ? How to prevent ? Some common causes of memory leaks made by developers. 

12. What are some basic principles to avoide memory leaks ?

13. Android Apk Creation process ?

14. Apk vs Bundle ? And How can we reduce Apk Size ?

15. Jetpack components. 

16. Retrofit & Okhttp internals ? How they work ? What problem they solve for us. 

17. How multipart requests work ? 

18. RoomDb how it works ? Why we need to write migrations if some table has changed ? 

19. Offilne First Architecture. What it is ? How to design one ? What should be the approach.

20. Many approach of desinging offilne first arch. When to choose what ? FileSystem, SQLite/Room, SharedPref etc etc. 

21. How multithreading works in general ? Threads cores etc. 

23. Database. 

25. What is init block in context of viewmodels, when we should and should't use it. 

26. Why any android specific component should never be passed to viewmodel, repository ? What is the correct way to do this then.   

27. How can we create our own live data ?

Advance Topics :

28. What are noinline/cross-inline modifiers in Kotlin?

30. What is the Contract API in Kotlin and how does it instruct the compiler about smart casts and flow?

31. What are context receivers (K2 feature)?

32. Can you explain Kotlin compiler phases and its plugin architecture?

33. What is expect/actual in Kotlin Multiplatform?

34. How do SAM conversions work and how does Kotlin interoperate with Java lambdas?

35. How do you write custom annotations and meta-annotations in Kotlin?

36. What is the performance impact of lambdas and allocations in tight loops?

37. How can you avoid hidden allocations in Kotlin (sequence {}, inline, object pooling)?

38. How do you perform bytecode inspection in Kotlin (Xdump-declarations, IntelliJ bytecode viewer)?

39. How do you design Kotlin-friendly APIs (idiomatic public APIs)?

40. How do coroutines work under the hood? Explain suspend function lowering.

41. What is advanced delegation in Kotlin (delegation to a map, intercepting property reads/writes)?

42. What is Kotlin Symbol Processing (KSP) and how does it differ from Annotation Processing (KAPT)?

43. Can you explain compiler plugins in Kotlin (e.g., Jetpack Compose compiler)?

44. WebRTC :
    Source Blog : https://getstream.io/blog/communication-protocols/
    https://github.com/GetStream/webrtc-android

    WebRTC (Web Real-Time Communication) is an open-source project that enables real-time, peer-to-peer
    communication directly between browsers or devices.
        - It supports audio, video, screen sharing, and data transfer.
        - Unlike WebSockets or gRPC, once the connection is established, data can flow directly
        between devices without passing through a server, reducing latency.
        - It's widely used in apps like Google Meet, Zoom, WhatsApp video calls, and multiplayer gaming.

    How WebRTC Works

    Setting up a WebRTC connection is complex because browsers/devices are often behind firewalls or NATs.
    The process involves several steps and components:

    1. Signaling (Initial Handshake)

        - WebRTC does not define its own signaling mechanism.
        - Signaling is how two peers discover each other and exchange connection information.
        - Typically done using WebSockets, but it could also be via REST APIs, email, or even manual exchange.
        - Data exchanged includes SDP (Session Description Protocol) which contains:
            - Media formats (audio/video codecs, resolutions)
            - Networking details
            - ICE candidates (possible connection routes).

    2. NAT and STUN Servers

        Most devices are behind NAT (Network Address Translation), which hides private IP addresses.
        - A STUN server helps devices discover their public IP and port mapping.
        - This allows one peer to know how it can be reached by another peer directly.
        - Works for most NAT types, except Symmetric NAT (most restrictive).

    3. TURN Servers (Fallback Option)

        - If direct P2P fails (e.g., both devices behind symmetric NATs), a TURN server relays the data between peers.
        - TURN adds latency and cost but ensures the connection works.

    4. ICE (Interactive Connectivity Establishment)

        - ICE is a framework that combines STUN and TURN to find the best route between two peers.
        - It gathers multiple possible network paths (called ICE candidates) and selects the optimal one.

    5. Peer-to-Peer Connection

        - Once peers exchange SDP and ICE candidates, a direct connection is established:
        - Audio/video streams and data are exchanged in real time.
        - If direct connection isn’t possible, traffic is routed via TURN.

    Advantages of WebRTC :
        - Low latency – ideal for real-time voice/video.
        - Peer-to-peer data transfer – reduces server load and bandwidth cost.
        - Built-in browser support – no plugins needed, APIs available in all modern browsers.
        - Supports rich features – screen sharing, file transfer, video conferencing.

    Drawbacks of WebRTC :

        - Complex to set up – requires STUN/TURN servers and a signaling mechanism.
        - No built-in signaling – must be implemented separately (often with WebSockets).
        - Scalability challenges – group calls may require additional infrastructure like SFU/MCU servers.
        - Relies on network conditions – poor connectivity can degrade call quality.

45. WebSocket :

    What is a Socket Connection?

    - A socket represents one endpoint of a two-way communication channel between a client and a server.
    - WebSocket, built on top of TCP, provides full-duplex communication, meaning both client and server
    can send and receive data simultaneously over a single persistent connection.
    - Commonly used for real-time apps like chat systems, live sports updates, multiplayer games, or stock tickers.

    How WebSockets Work :

    1. Handshake (HTTP Upgrade)
        - The connection starts as an HTTP request.
        - The client sends an Upgrade header to switch the protocol to WebSocket.
        - Example: GET /chat HTTP/1.1
                   Host: example.com
                   Upgrade: websocket
                   Connection: Upgrade

    2. Persistent Connection
        - Once upgraded, a single TCP connection remains open, allowing both sides to exchange messages freely.

    3. Bi-directional Data Flow
        - Any type of data (text or binary) can be sent.
        - The connection stays alive until explicitly closed by the client or server.

    Key Features

        - Real-time, low-latency messaging.
        - Lightweight compared to polling – no repeated HTTP requests.
        - Simple to implement – supported by all modern browsers.
        - Flexible – no strict data format required.

    Limitations

        - No built-in multiplexing (each browser tab = separate connection).
        - Must manually handle reconnections, load balancing, and failover.
        - Less efficient for large file transfers or video/audio streaming compared to WebRTC.


46. When to choose WebRTC vs WebSokets

    When to Choose WebRTC
        - You need real-time voice/video streaming.
        - P2P is important to reduce server bandwidth costs.

    Applications like:
        - Video conferencing
        - Live streaming
        - Peer-to-peer file transfer
        - Multiplayer games requiring very low latency.

    When to Choose WebSockets ?

    - You need real-time messaging but not complex media handling.
    - All data should pass through a centralized server for control/security.

    Simpler implementation, e.g.:
        - Chat apps
        - Real-time dashboards
        - Live sports scores
        - Stock trading tickers.
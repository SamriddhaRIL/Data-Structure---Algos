
1. How does findViewById work internally ?
Ans : 
 In the XML file when we add an element and set the properties to it we only set the values for these properties,
 now for each element, there is a class that draws it at the screen, this class has attributes with the 
 same names of the properties in the XML file now using algorithms of read-write from files these values 
 from the XML file are transmitted to the java file (class) of the element, and then the class draws that element on the screen.
 Before the class of the element draws it, there is a superclass of all elements,
 the parent for all of them it is called View (every element in the activity is called view) this class has the basic
 properties of all elements and this class is the one which the properties from the XML file will be transmitted to it.
 Method findViewById() returns an object of View type, this object holds the properties values then we need to cast it to the specific element, for example, TextView which is a class to draw the text view this class and all elements' classes are 
 subclasses of View class so what we do is downcasting, that when this method returns the object of View type we downcast it to the element class
 How it finds the properties? it finds the properties of the element using the id if the tag in the XML file first it searches in t
 he XML file for the tag that holds the element's name and then it looks at the id if it is the id which it wants then it takes it 
 otherwise it searches for another tag (with the same element name).
 We give it the id by this approach. there is a class is called R (resources),
 this class has nested classes (id, string, colors) these classes have attributes from the same type and hold specific values,
 for instance, the id class it has attributes that stores each id of each element in the XML file,
 so when we want to give the method findViewById() the id we go to this class and tell it to enter id class and choose the id of the element we want.
 And the process goes that it enters to the XML file and look for the element that has this id and it takes the properties and passes them to the 
 class view object and when it returns the object we downcast it to the element's class that we want to draw it and deal with it.
 Thread : https://stackoverflow.com/questions/35357734/how-does-findviewbyid-work
 Very good explanation : https://medium.com/@sm3.saurabhmishra/android-deep-dive-findviewbyid-547177fbe880


2. What is AIDL in android ? 

And : https://developer.android.com/develop/background-work/services/aidl

✅ What is AIDL (Android Interface Definition Language)?

AIDL is Android’s way to define interfaces for Inter-Process Communication (IPC) between components running in different processes.
✨ Think of it like:

    AIDL is a contract between two Android components — usually from different apps — that want to talk to each other securely and efficiently.

For example:

    App A wants to get data from a service running in App B (e.g., getting the location, playing music, managing files).

    Android doesn't allow direct memory access across processes.

    So objects must be marshalled (serialized) and unmarshalled safely across process boundaries. AIDL handles this behind the scenes.

📌 When Should You Use AIDL?

Use AIDL if:

    You’re exposing a bound service to clients from different apps (processes).

    You want to handle multithreading in the service.

    You need high-performance, bidirectional communication (like callbacks, or data streams).

Don’t use AIDL if:

    You only need IPC within the same app → just use Binder directly.

    You don’t need multithreading → use Messenger.

🧠 Key Concepts & Things to Remember
Concept	Description
.aidl File	Defines the interface. Like IRemoteService.aidl.
Stub Class	Generated automatically; you extend this to implement the interface.
Binder	Android's base class for inter-process communication.
onBind()	Returns the implementation of the Stub to clients.
asInterface()	Used on the client side to get the usable object from the IBinder.
in, out, inout	Directional tags for complex types (not needed for primitives).
oneway	Marks methods as asynchronous/non-blocking.
Threading	IPC methods run on a Binder thread pool, not UI thread — always ensure thread safety!
📦 Real-world Example Use Cases

Here are some real Android system-level examples where AIDL is used — talk about these in your interview for a strong impression.
1. Android System Services

Many system services are defined via AIDL. For example:
🧭 LocationManagerService

    You call LocationManager to get GPS coordinates.

    Under the hood, it uses ILocationManager.aidl to communicate with the system service running in another process.

    This allows apps to request location updates from the centralized system process securely.

🎧 Media playback

    IMediaPlayerService.aidl & IMediaSession.aidl

    Used when apps communicate with the system's audio playback pipeline — like in Spotify, YouTube, or Google Play Music.

2. Play Store

    Google Play Services uses AIDL to expose APIs (e.g., license verification, in-app billing).

    Apps like your game can use IInAppBillingService.aidl to talk with the Play Store securely and perform in-app purchases.


Two apps:

    App A (Client) – Wants to get data

    App B (Service) – Offers the data via an AIDL interface

📊 Diagram – AIDL IPC Flow

[App A: Client]                                 [App B: Service]
----------------                                 ----------------
1. IRemoteService.aidl       --->               1. IRemoteService.aidl
2. bindService()             --->               2. onBind() returns Stub
3. onServiceConnected()      <---               3. Stub is sent as IBinder
4. call remote method        --->               4. Method runs in App B's thread pool
5. result returned           <---               5. Service processes and sends response

Both apps must include the same .aidl file in src/main/aidl.    


- What is a Bound Service, and how does AIDL use it?
📌 Bound Service:

A bound service is a service that allows components (clients) to bind to it and interact via a persistent connection — like calling methods, receiving callbacks, etc.
🤝 Relationship with AIDL:

AIDL is one way to define the interface that clients can use when they bind to the service. It’s especially used when:

    The client is from a different app/process

    You need complex or high-performance IPC

Service Lifecycle in Bound Service:

    onBind() is triggered when a client binds.

    It returns an IBinder object (Stub generated from AIDL).

    The client uses this to call remote methods.



3. What is Binder Class ?

4. Bound Service ?
Video : https://www.youtube.com/watch?v=_xNkVNaC9AI

5. What is init block in context of viewmodels, when we should and should't use it. 

6. Why any android specific component should never be passed to viewmodel, repository ? What is the correct way to do this then.   

7. How can we create our own live data ? 

8. How to create LRU cache ? 

9. How view models work internally to preserve data accorss configuration changes ? 

10. What are sealed classes in kotlin ? What is advantage of using it compared to normal enums ? 

11. What are memory leaks ? How to detect ? How to prevent ? Some common causes of memory leaks made by developers. 

12. What are some basic principles to avoide memory leaks ? 

13. How coroutines work internally ? Differece between coroutines and threads. 

14. Flow API, how it works. 

15. Jetpack components. 

16. Retrofit & Okhttp internals ? How they work ? What problem they solve for us. 

17. How multipart requests work ? 

18. RoomDb how it works ? Why we need to write migrations if some table has changed ? 

19. Offilne First Architecture. What it is ? How to design one ? What should be the approach.

20. Many approach of desinging offilne first arch. When to choose what ? FileSystem, SQLite/Room, SharedPref etc etc. 

21. How multithreading works in general ? Threads cores etc. 

23. Database. 

Problem link = https://leetcode.com/problems/maximum-subarray/description/
Video Explenation : https://www.youtube.com/watch?v=AHZpyENo7k4&feature=youtu.be

53. Maximum Subarray
Given an integer array nums, find the
subarray
with the largest sum, and return its sum.
 

Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:

Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.

Example 3:

Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

 

Constraints:

    1 <= nums.length <= 105
    -104 <= nums[i] <= 104

 

Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.


##### Solution ##############################

Brude Force approach is to use three loops with i,j,k 
i will be starting of the sub array j will be ending of the array and k will iterate between i and j to calculate the 
sum of every subarray between i - j. We will update the result if new sum is bigger than the previous one. 

int maxSubarraySum(int arr[], int n) {
    int maxi = INT_MIN; // maximum sum

    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            // subarray = arr[i.....j]
            int sum = 0;

            //add all the elements of subarray:
            for (int k = i; k <= j; k++) {
                sum += arr[k];
            }

            maxi = max(maxi, sum);
        }
    }

    return maxi;
}

We can maybe eliminate the third loop but adding the nums[j] element to the last sum we calculated. 
But this is still taking O(n2) time. Time limit exceed on leetcode.

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int result=nums[0];
        for(int i=0;i<n;i++){
            int sums=0;
            for(int j=i;j<n;j++){
                sums = sums+nums[j];
                result = max(sums,result);
            }
        }
        return result;
    }
};


Now we come to Optimal solution which is to Kadanes Algorithm : 

Intuition:

The intuition of the algorithm is not to consider the subarray as a part of the answer if its sum is less than 0. A subarray with a sum less than 0 will always reduce our answer and so this type of subarray cannot be a part of the subarray with maximum sum.
Here, we will iterate the given array with a single loop and while iterating we will add the elements in a sum variable. Now, if at any point the sum becomes less than 0, we will set the sum as 0 as we are not going to consider any subarray with a negative sum. Among all the sums calculated, we will consider the maximum one.
Thus we can solve this problem with a single loop.

Approach:
The steps are as follows:
    We will run a loop(say i) to iterate the given array.
    Now, while iterating we will add the elements to the sum variable and consider the maximum one.
    If at any point the sum becomes negative we will set the sum to 0 as we are not going to consider it as a part of our answer.

Note: In some cases, the question might say to consider the sum of the empty subarray while solving this problem. So, in these cases, before returning the answer we will compare the maximum subarray sum calculated with 0(i.e. The sum of an empty subarray is 0). And after that, we will return the maximum one.
For e.g. if the given array is {-1, -4, -5}, the answer will be 0 instead of -1 in this case. 


class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int result=INT_MIN;
        int sums=0;
        for(int i=0;i<n;i++){
            sums += nums[i];
            result = max(sums,result);
            if(sums<0) sums=0;
        }
        return result;
    }
};


In a variation to this question if it is asked to print the subarray we can add two more variables there 
to store the start index and end index. 

int maxSubarray(int nums[],int size) {
        int n = size;
        int result=-11212;
        int sums=0;
        int startIndex,endIndex;
        for(int i=0;i<n;i++){
            if(sums==0) startIndex=i; 
            sums += nums[i];
            if(sums>result){
                result = sums;
                endIndex=i;
            }
            if(sums<0) sums=0;
        }
        
        std::cout << startIndex << std::endl;
        std::cout << endIndex << std::endl;

        return result;
}

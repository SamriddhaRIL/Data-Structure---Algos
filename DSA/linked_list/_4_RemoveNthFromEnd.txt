Problem Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
Explanation : https://www.youtube.com/watch?v=3kMKYQ2wNIU


19. Remove Nth Node From End of List
Solved
Medium
Topics
premium lock iconCompanies
Hint

Given the head of a linked list, remove the nth node from the end of the list and return its head.


Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:
Input: head = [1], n = 1
Output: []

Example 3:
Input: head = [1,2], n = 1
Output: [1]

Constraints:
    The number of nodes in the list is sz.
    1 <= sz <= 30
    0 <= Node.val <= 100
    1 <= n <= sz

Follow up: Could you do this in one pass?


############################### My answer ############################################

Time Complexity: O(n)

First pass: You traverse the entire list once to calculate its size - O(n)
Second pass: You traverse up to (size - n) nodes to reach the node before the one to delete - O(n) in worst case
Overall: O(n) + O(n) = O(n)

Space Complexity: O(1)

You only use a constant amount of extra space regardless of input size
Variables used: temp, size, pointTobeDeleted, pre, toBeDeletedNode - all constant space
No recursion or additional data structures that scale with input size

public Node removeNthFromEnd(Node head, int n) {

        // Empty / not a vaild list
        if(head==null){
            return head;
        }

        // Find out the size of the list
        Node temp = head;
        int size=0;
        while(temp!=null){
            temp = temp.next;
            size++;
        }

        // Check if the position we are trying to delete is valid one.
        if(n>size||n<=0){
            System.out.println("Not a valid position to delete");
            return head;
        }

        // Determine the position to be deleted
        int pointTobeDeleted = (size - n);

        // If deleting 1st node : Head needs to be readjusted.
        if(pointTobeDeleted==0){
            temp = head;
            head = head.next;
            temp = null;
            return head;
        }

        // Determine the node previous to one we are trying to delete.
        size=1;
        Node pre = head;
        while(size<pointTobeDeleted){
            pre = pre.next;
            size++;
        }

        // Change the pointer of the previous node. Then delete the node.
        Node toBeDeletedNode = pre.next;
        pre.next = toBeDeletedNode.next;
        toBeDeletedNode = null;

        return head;
    }

############################### Using fast & Slow Pointers : One pass solution ############################################

Time Complexity: O(n)
Space Complexity: O(1)

Same time and space complexity but in one iteration .
Fast & Slow Pointer (One Pass):
Single pass: Move both pointers simultaneously
Total traversals: Exactly n nodes

public Node removeNthFromEndFastAndSlowPointers(Node head, int n) {

        // Empty / not a vaild list
        if(head==null){
            return head;
        }

        if(n<=0){
            return head;
        }

        // Find out the size of the list
        Node dummy = new Node(Integer.MIN_VALUE);
        dummy.next = head;
        Node slow = dummy;
        Node fast = head;

        int i=1;
        while (i<=n&&fast!=null){
            fast = fast.next;
            i++;
        }

        // If fast is null and we haven't moved n steps, n is larger than list size
        if (fast == null && i <= n) {
            System.out.println("\nInvalid Position");
            return head; // Invalid n, return original list
        }

        while(fast!=null){
            slow = slow.next;
            fast = fast.next;
        }

        slow.next = slow.next.next;

        return dummy.next;
    }
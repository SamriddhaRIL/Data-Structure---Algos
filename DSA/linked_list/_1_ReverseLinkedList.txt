Problem Link : https://leetcode.com/problems/reverse-linked-list-ii/description/
Intuition : https://www.youtube.com/watch?v=wk8-_M-2fzI

92. Reverse Linked List II
Solved
Medium
Topics
premium lock iconCompanies

Given the head of a singly linked list and two integers left and right where left <= right,
reverse the nodes of the list from position left to position right, and return the reversed list.

Example 1:

Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]

Example 2:

Input: head = [5], left = 1, right = 1
Output: [5]

Constraints:

    The number of nodes in the list is n.
    1 <= n <= 500
    -500 <= Node.val <= 500
    1 <= left <= right <= n


Follow up: Could you do it in one pass?


======================== Solution One ====================================================================
Time Complexity: O(n)
- The first while loop runs left-1 times to find the position before the reversal starts
- The for loop runs right-left times to perform the actual reversal
- In the worst case, if left=1 and right=n (reversing the entire list), the total operations would be 0 + (n-1) = n-1
Therefore, the time complexity is O(n) where n is the length of the linked list

Space Complexity: O(1)

public Node reverseBetween(Node head, int left, int right) {

        if(head==null||head.next==null||left==right) return head;

        Node dummy = new Node(Integer.MIN_VALUE);
        dummy.next = head;

        Node PRE=dummy,CURRENT=null,NEXT=null;
        int i=0;
        while(i<left-1){
            PRE = PRE.next;
            i++;
        }

        CURRENT = PRE.next;
        for (int j=left;j<right;j++){
            NEXT = CURRENT.next;
            CURRENT.next = NEXT.next;
            NEXT.next = PRE.next;
            PRE.next = NEXT;
        }

        return dummy.next;
    }

======================== Same As Solution One But With Single loop ====================================================================


public Node reverseBetweenSingleLoop(Node head, int left, int right) {

        if(head==null||head.next==null||left==right) return head;

        Node dummy = new Node(Integer.MIN_VALUE);
        dummy.next = head;

        Node PRE=dummy,CURRENT=null,NEXT=null;
        for (int i=0;i<right;i++){
            if(i<left-1){
                PRE = PRE.next;
            }else if (i == left - 1) {
                CURRENT = PRE.next;
            }else {
                NEXT = CURRENT.next;
                CURRENT.next = NEXT.next;
                NEXT.next = PRE.next;
                PRE.next = NEXT;
            }
        }

        return dummy.next;
    }


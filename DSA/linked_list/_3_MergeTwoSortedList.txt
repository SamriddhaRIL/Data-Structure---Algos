Problem Link : https://leetcode.com/problems/merge-two-sorted-lists/submissions/1737106912/

Merge Two Sorted Lists
Solved
Easy
Topics
premium lock iconCompanies

You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.

Example 1:

Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]

Example 2:

Input: list1 = [], list2 = []
Output: []

Example 3:

Input: list1 = [], list2 = [0]
Output: [0]

Constraints:

    The number of nodes in both lists is in the range [0, 50].
    -100 <= Node.val <= 100
    Both list1 and list2 are sorted in non-decreasing order.



################################## First solution ########################################

Time Complexity: O(m + n)
Parameters:
m = number of nodes in list1
n = number of nodes in list2

Space Complexity: O(m + n)

Memory Allocations:
New nodes created: m + n nodes (one for each input element)
Dummy node: 1 additional node
Pointer variables: Constant number (dummy, mergedList, etc.)

public Node mergeTwoListExtraSpace(Node list1, Node list2) {
        if(list1==null&&list2==null) return null;
        if(list1 == null) return list2;
        if(list2 == null) return list1;

        Node dummy = new Node(Integer.MIN_VALUE);
        Node mergedList = dummy;

        while(list1!=null || list2!=null){
            if (list1==null){
                mergedList.next = new Node(list2.data);
                list2 = list2.next;
            } else if (list2 == null){
                mergedList.next = new Node(list1.data);
                list1 = list1.next;
            }else if (list1.data<list2.data){
                mergedList.next = new Node(list1.data);
                list1 = list1.next;
            }else if (list2.data<list1.data) {
                mergedList.next = new Node(list2.data);
                list2 = list2.next;
            }else {
                mergedList.next = new Node(list1.data);
                mergedList = mergedList.next;
                mergedList.next = new Node(list2.data);
                list1 = list1.next;
                list2 = list2.next;
            }
            mergedList = mergedList.next;
        }

        return dummy.next;
    }


############################### My solution #############################################

Time Complexity: O(m + n)
Analysis:
m = length of list1
n = length of list2

Space Complexity: O(1)
Auxiliary Space: O(1) - Constant extra space
No additional data structures: No arrays, lists, or recursion stack used
Only pointer variables: You only use a few pointer variables:

dummy (1 new node)
mergedList (pointer)
Input pointers are reused

In-place rearrangement: You're rearranging existing nodes, not creating new ones (except dummy)



public Node mergeTwoLists(Node list1, Node list2) {
        if(list1==null&&list2==null) return null;
        if(list1 == null) return list2;
        if(list2 == null) return list1;

        Node dummy = new Node(Integer.MIN_VALUE);
        Node mergedList = dummy;
        dummy.next = mergedList;

        while(list1!=null || list2!=null){
            if (list1==null){
                mergedList.next = list2;
                list2 = list2.next;
            } else if (list2 == null){
                mergedList.next = list1;
                list1 = list1.next;
            }else if (list1.data<list2.data){
                mergedList.next = list1;
                list1 = list1.next;
            }else if (list2.data<list1.data) {
                mergedList.next = list2;
                list2 = list2.next;
            }else {
                mergedList.next = list1;
                mergedList = mergedList.next;
                list1 = list1.next;

                mergedList.next = list2;
                mergedList = mergedList.next;
                list2 = list2.next;
                continue;
            }
            mergedList = mergedList.next;
        }

        return dummy.next;
    }


############################### Optimised Solution #############################################

Same time & space complexity as the above solution but with more clean & concise code.

public Node mergeTwoListsOptimised(Node list1, Node list2) {

        if(list1==null&&list2==null) return null;
        if(list1 == null) return list2;
        if(list2 == null) return list1;

        Node dummy = new Node(Integer.MIN_VALUE);
        Node mergedList = dummy;

        while(list1!=null&&list2!=null){

            // compare the l1 vs l2 nodes value and rearrange the currentNode
            if (list1.data<list2.data){
                mergedList.next = list1;
                list1 = list1.next;
            }else {
                mergedList.next = list2;
                list2 = list2.next;
            }
            mergedList = mergedList.next;
        }

        // If remaining values there just append the rest
        if(list1==null){
            mergedList.next = list2;
        }

        if(list2==null){
            mergedList.next = list1;
        }

        return dummy.next;
    }



74. Search a 2D Matrix
Leetcode link : https://leetcode.com/problems/search-a-2d-matrix/description/
Youtube solution link : https://www.youtube.com/watch?v=JXU4Akft7yk

You are given an m x n integer matrix matrix with the following two properties:

    Each row is sorted in non-decreasing order.
    The first integer of each row is greater than the last integer of the previous row.

Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.

 

Example 1:

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

Example 2:

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false

 

Constraints:

    m == matrix.length
    n == matrix[i].length
    1 <= m, n <= 100
    -104 <= matrix[i][j], target <= 104

##### Solution ###### 

Brude Force Approch is to solve it by going through each and every element. If we found the target then return true else 
return false. 

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[i][j]==target) return true;
            }
        }
        return false;
    }
};

Time Complexity: O(N X M), where N = given row number, M = given column number.
Reason: In order to traverse the matrix, we are using nested loops running for n and m times respectively.

Space Complexity: O(1) as we are not using any extra space.

####### Better Solution #############

In this solution we instead of going through each and every element we try to 
reduce the iteration by first check if there is a chance of existent of the targe in a particular row.
We can do that as we already know the matrix is sorted in assening order. 
So this particualr if statement is true 
(target>=matrix[i][0] && target <= matrix[i][m-1]) 
we iterate throught that particular row otherwise we go to the next row and dont iterate for each and every row. 

Time complexity : O(n+m)

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i=0;i<n;i++){
            if (target>=matrix[i][0] && target <= matrix[i][m-1])
            {
                if (target==matrix[i][m-1]) return true;
                else if (target==matrix[i][0]) return true;
                else{
                    for(int j=1;j<m-1;j++){
                        if(matrix[i][j]==target) return true;
                    }
                }
            }
        }
        return false;
    }
};


Now we can further optimize this by doing the search operation using binary search and not iterating through
the entire row. 

bool binarySearch(vector<int>& nums, int target) {
    int n = nums.size(); //size of the array
    int low = 0, high = n - 1;

    while (low <= high) {
        int mid = (low + high) / 2;
        if (nums[mid] == target) return true;
        else if (target > nums[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return false;
}

bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i=0;i<n;i++){
            if (target>=matrix[i][0] && target <= matrix[i][m-1])
            {
                return binarySearch(matrix[i],target);
            }
        }
        return false;
}

Complexity Analysis

Time Complexity: O(N + logM), where N = given row number, M = given column number.
Reason: We are traversing all rows and it takes O(N) time complexity. But for all rows, we are not applying binary search rather we are only applying it once for a particular row. That is why the time complexity is O(N + logM) instead of O(N*logM).

Space Complexity: O(1) as we are not using any extra space.



